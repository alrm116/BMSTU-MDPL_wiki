## RISC-архитектура
```
Архитектура x86 относится к группе архитектур CISC.

Первые ПК создавались в эпоху, когда ЯВУ практически не было, 
поэтому люди стремились сделать как можно больше возможностей 
на аппаратном уровне (на уровне процессора), чтобы программисты, 
которые писали на ассемблере, могли пользоваться всеми аппаратными 
ресурсами ПК. Отсюда в x86 (начиная с 8086) базовый набор команд 
достаточно объёмный. Тут есть и строковые команды, и команды 
обработки упакованных двоично-десятичных чисел, и разнообразные 
арифметические команды, и разные способы адресации, и т.д.

Однако для компиляторов ЯВУ (например, Си) определение оптимального 
набора инструкций для трансляции кода на этом языке в ассемблерный - 
задача очень сложная и практически не решаемая. Поэтому компиляторы 
используют довольно ограниченный набор простых команд, игнорируя 
в целях оптимизации некоторые сложные команды, которые были придуманы 
людьми, которые думали что все будут писать только на ассемблере и 
хотели упростить жизнь программистам.
```
И сейчас строковые команды [такие](https://memepedia.ru/wp-content/uploads/2019/09/mayk-vazovski-s-litsom-salli-8.jpg)

```
В общем, так исторически сложилось, что в ассемблере x86 есть 
избыточные команды, т.е. процессор ими перегружен.

Другой вариант архитектуры, по которому позже пошли разработчики 
архитектуры ARM, - RISC...
```

#### Ранние архитектуры процессоров (комплексные, **CISC** (Complex instruction set computer)):
- большее количество команд
- разные способы адресации для упрощения написания программ на ассемблере
- поддержка конструкций языков высокого уровня
Недостатки: на практике многие возможности **CISC** используются компиляторами ЯВУ ограниченно, а их поддержка затратна.

#### **RISC** (reduced instruction set computer):
- сведение набора команд к простым типовым
- большее количество регистров (возможно за счёт общего упрощения архитектуры) - позволяет писать более быстрые программы
- стандартизация формата команд, упрощение конвейеризации (грубо говоря, это то, как процессор разбирает команды), т.е. команды стало удобнее выполнять параллельно (или [квазипараллельно](https://studfile.net/preview/3177525/page:30/), про это мы уже говорили [ранее](https://github.com/Inspirate789/BMSTU-MDPL/wiki/%D0%9B%D0%B5%D0%BA%D1%86%D0%B8%D1%8F-5#:~:text=%D0%BF%D1%80%D0%B5%D1%80%D1%8B%D0%B2%D0%B0%D0%BD%D0%B8%D0%B9%20%D0%B8%20%D0%B8%D1%81%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B9.-,%D0%9A%D0%B0%D0%BA,-%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D1%83%D0%B5%D1%82%D1%81%D1%8F%20%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C%20%D0%BD%D0%B0)) за счёт того, что они стали более типовыми



## Семейство процессоров ARM
#### Свыше 90% рынка процессоров для мобильных устройств
#### ARMv1 – 1985 г. (примерно во времена процессора 80286)
Здесь есть понятия _семейств процессоров_, _версий архитектуры_ и _профайлов_ (направленность процессоров, т.е. то, подо что они заточены с точки зрения энергопотребления, производительности и т.д.).
#### Современные версии архитектуры - ARMv7, ARMv8.
#### Профайлы (обычно кодируются последней буквой в названии архитектуры): 
- Classic
- Microcontroller
- Real-time (специализирован под выполнение задач в режиме реального времени)
- Application (самый распространённый, устанавливается в прикладных пользовательских устройствах)

```
Забегая вперёд в курс ОС:
Режимы реального времени делятся на 2 группы:
- Режимы мягкого реального времени: 
  для обработки звука или видео, т.е. воспроизведения файлов 
  с определённой скоростью без потерь и провалов. Если какие-то 
  потери всё-таки возникнут, то ничего страшного не произойдёт.
- Режимы жёсткого реального времени: что-то совсем строгое, где 
  требуется гарантированное время отклика, причём очень маленькое 
  (в пределах микросекунд). Требуется в каком-то оборудовании, где 
  нельзя потерять какой-то сигнал или не отдать вовремя команду 
  какому-нибудь приводу, потому что это может закончиться аварией.
```

#### Регистры общего назначения ARMv7:
- `R0`-`R12`
- `R13` – `SP` (Stack Pointer)
- `R14` – `LR` (регистр связи) - используется при адресации и для быстрого вызова подпрограмм (см. далее)
- `R15` – `PC` (счётчик команд) - как `IP`, только не Instruction Pointer, а Program Counter

```
Вспомним защищённый режим в архитектуре x86, где нам необходимо 
сохранять регистры при переключении режима работы процессора на 
уровне ОС. Для аналогичных целей в архитектуре ARM (Семейство RISC), 
ввиду наличия в ней большего числа регистров, есть возможность 
физически раздваивать регистры.
```

Регистры `R8`–`R12` существуют в двух экземплярах:
- для режима обработки быстрого прерывания (см. далее)
- для остальных режимов
Регистры `LR` и `SP` для каждого режима работы процессора свои (6-7 пар)



## Режимы ARM
- **User mode** — обычный режим выполнения программ (аналогично [3 кольцу защиты в **x86**](https://github.com/Inspirate789/BMSTU-MDPL/wiki/%D0%9B%D0%B5%D0%BA%D1%86%D0%B8%D1%8F-5#:~:text=%D1%81%20%D1%82%D0%B5%D0%BA%D1%83%D1%89%D0%B8%D0%BC%20%D1%81%D0%B5%D0%B3%D0%BC%D0%B5%D0%BD%D1%82%D0%BE%D0%BC.-,%D0%AD%D1%82%D0%B8,-%D1%87%D0%B8%D1%81%D0%BB%D0%B0%20%D0%BE%D1%82%200)). В этом режиме выполняется большинство программ.
- **Fast Interrupt** (FIQ) — режим быстрого прерывания (меньшее время срабатывания).
- **Interrupt** (IRQ) — основной режим прерывания.
- **System mode** — защищённый режим для использования операционной системой. в нём работает ядро ОС.
- **Abort mode** — режим, в который процессор переходит при возникновении ошибки доступа к памяти (доступ к данным или к инструкции на этапе _prefetch_ конвейера). Аналогичен исключению в **x86**, возникающему при обращении к странице, которая выгружена из памяти.
- **Supervisor mode** — привилегированный пользовательский режим.
- **Undefined mode** — режим, в который процессор входит при попытке выполнить неизвестную ему инструкцию. По сути это исключение, если рассуждать в терминологии **x86**.



## Наборы команд ARM
- **Базовый ARM** (32-разрядные) - набор команд, созданный ещё в 1985
- **Thumb** (16-разрядные, более производительные) - появились позже в целях оптимизации (занимают меньше места). По сути в них "завернули" базовые команды, частично ограничив их (присвоив им более короткие коды, в т.ч. за счёт сокращения операндов). Процессор выполняет их аналогично базовым, перекодировывая их "на лету".
- **Thumb2** (32-разрядные) - дополнение набора Thumb за счёт расширения до 32 бит и добавления новых команд
- **A64** (64-разрядные) - для 64-разрядных версий процессоров ARM. Речь о последнем поколении процессоров ARMv8, которое начало появляться с 2011 года (промышленные образцы появились позже)

```
А в плане разрядности ARM отстаёт от x86 примерно на 10 лет.
```



## Расширения ARM
- **VFP v1-v5** - аналог **[FPU](https://github.com/Inspirate789/BMSTU-MDPL/wiki/%D0%9B%D0%B5%D0%BA%D1%86%D0%B8%D1%8F-6)** в **x86**, предназначенный для работы с числами с плавающей запятой. Существует в разных версиях, которые чисто технически не особо отличаются как друг от друга, так и от **FPU** в **x86**
- **SIMD**, **NEON** (Advanced SIMD), **SVE** - аналоги **SSE**/**MMX** в **x86**, предназначенные для поточной обработки данных
- **AES**, **SHA** - расширения для работы с криптографией и хешами (поддержка быстрого шифрования)



## Current Program Status Register (CPSR)
![image](https://user-images.githubusercontent.com/84042050/169643491-6fc03860-8059-4cb1-8453-05e2d284f5ce.png)



## Быстрые (FIQ) и обычные (IRQ) прерывания
**Fast interrupt** - режим для получения данных от оборудования, минимизирующий задержки:
- скорость обработки выше;
- допустима работа только одного обработчика единовременно.
**Standart interrupt** - все прочие прерывания.



## Команды ветвления B, BL, BLX
- `B` (Branch) - переход
- `BL` (Branch with link) - переход с сохранением адреса возврата в `LR`
- `BLX` - переход с переключением системы команд



## Вызов программного прерывания
```asm
SWI immed_8 (0..255)
```
Переводит процессор в **Supervisor mode**, `CPSR` сохраняется в **Supervisor Mode** `SPSR`, управление передаётся обработчику прерывания по вектору.



## Архитектура VLIW. Эльбрус-8С
**VLIW** (Very Large Instruction Word) - продолжение идей **RISC** для многопроцессорных систем. В каждой инструкции явно указывается, что должно делать каждое ядро процессора.

#### Эльбрус-8С:
- 8 ядер
- в каждом ядре - 6 арифметико-логических каналов со своими АЛУ и FPU, до 24 операций за такт



## Широкая команда Эльбруса
**Широкая команда** - набор элементарных операций, которые могут быть запущены на исполнение в одном такте.<br>
Доступны:
- 6 АЛУ (возможности различны)
- Устройство передачи управления
- 3 устройства для операций над предикатами
- 6 квалифицирующих предикатов
- 4 устройства асинхронного для команд чтения данных
- 4 32-разрядных литерала для констант



## Определяющие свойства архитектуры "Эльбрус"
- **Регистровый файл** (рабочие регистры) - 256 регистров (32 для глобальных данных и 224 для стека процедур)
    - механизм регистровых окон: вызывающая подпрограмма выделяет вызываемой область в своём регистровом окне; на начало указывает регистр `WD`
    - пространство регистров подвижной базы - пространство в текущем окне, на начало указывает регистр `BR`
- **Предикатный файл** - 32 регистра со значениями `true`/`false`
- **Подготовка передачи управления** (`disp`) - подготовка к переходам при ветвлении для исключения задержек
- Асинхронный доступ к массивам



## Java. Java virtual machine (JVM)
#### **Java** - объектно-ориентированный язык программирования, разработанный компанией Sun Microsystems.
Приложения Java обычно транслируются в специальный байт-код, поэтому они могут работать на любой компьютерной архитектуре, для которой существует реализация виртуальной Java-машины.

#### **Байт-код Java** — набор инструкций, исполняемых виртуальной машиной Java. Каждый код операции байт-кода — один байт.
Группы инструкций:
- загрузка и сохранение (например, `ALOAD_0`, `ISTORE`),
- арифметические и логические операции (например, `IADD`, `FCMPL`),
- преобразование типов (например, `I2B`, `D2I`),
- создание и преобразование объекта (например, `NEW`, `PUTFIELD`),
- управление стеком (например, `DUP`, `POP`),
- операторы перехода (например, `GOTO`, `IFEQ`),
- вызовы методов и возврат (например, `INVOKESTATIC`, `IRETURN`).
**javap** - дизассемблер файлов классов Java



## Платформа .NET. CLR, CIL
#### **.NET** (2002) - платформа, основанная на CLR (Common Language Runtime, общеязыковая исполняющая среда).
#### **CLR** — исполняющая среда для байт-кода **CIL (MSIL)**, в которой компилируются программы, написанные на .NET-совместимых языках программирования.
#### **CIL** (Common Intermediate Language) — «высокоуровневый ассемблер» виртуальной машины **.NET**, основанный на работе со стеком.
```asm
ldloc.0    // push local variable 0 onto stack
ldloc.1    // push local variable 1 onto stack
add        // pop and add the top two stack items then push the result 
           // onto the stack
stloc.0    // pop and store the top stack item to local variable 0
```
**ildasm**, **ilasm** - дизассемблер/ассемблер промежуточного языка (intermediate language)



## WebAssembly (wasm)
**WebAssembly** — это бинарный формат инструкций для стековой виртуальной машины, предназначенной для компиляции программ на ЯВУ (C, C++, C#, Go, TypeScript/AssemblyScript, Kotlin, Pascal, Rust, D, Erlang) для WEB.

![image](https://user-images.githubusercontent.com/84042050/169644004-b43aceb6-8ecb-4246-92d6-2e1d29b1316a.png)

