## Макроопределения.
```
"Работают точно так же, как и в Си."
```
**Макроопределение (макрос)** - именованный участок программы, который ассемблируется каждый раз, когда его имя встречается в тексте программы.
### `Макросы обрабатываются препроцессором`.
- Определение:
```asm
имя MACRO параметры
...
ENDM
```
- Пример:
```asm
load_reg MACRO register1, register2
push register1
pop register2
ENDM
```



## Директива присваивания `=`.
Директива присваивания служит для создания целочисленной макропеременной или изменения её значения и имеет формат:
```asm
Макроимя = Макровыражение
```
- **Макровыражение (или Константное выражение)** - **выражение, вычисляемое препроцессором**, которое может включать целочисленные константы, макроимена, вызовы макрофункций, знаки операций и круглые скобки, **результатом вычисления которого является целое число**
- Операции: арифметические (+, -, *, /. MOD), логические, сдвигов, отношения (сравнения)



## Директивы отождествления `EQU`, `TEXTEQU`.
Директива для представления текста и чисел:
```asm
Макроимя EQU нечисловой текст и не макроимя ЛИБО число
```
```asm
Макроимя EQU <Операнд>
```
`TEXTEQU` никак не обрабатывает выражение и просто присваивает его как текстовую строку левой части выражения (макроимени).
```asm
Макроимя TEXTEQU Операнд
```
Пример:
```asm
X EQU [EBP+8]
MOV ESI,X
```



## Макрооперации.
Помимо очевидных арифметических операций, есть специфические операции
- **`%`** - вычисление выражения перед представлением числа в символьной форме (позволяет подставлять куда-либо результаты вычислений в качестве текстового значения)
- **`<>`** - подстановка текста без изменений (без конкатенаций или арифметических вычислений, т. е. не изменяя операнд и не интерпретируя его как выражение)
- **`&`** - склейка текста (конкатенация слов)
- **`!`** - считать следующий символ текстом, а не знаком операции (можно ставить перед знаками `<`, `>`, `=` и т.д.)
- **`;;`** - исключение строки из макроса (**комментарий в макросе**). Если в макросах ставить `;`, которые мы обычно используем для строковых комментариев, то эта строка попадёт в результат работы макроса!



## Блоки повторения.
- Повтор фиксированное число раз
```asm
REPT число … ENDM
```
- Подстановка фактических параметров по списку на место формального: `IRP `или `FOR` (в разных версиях masm'а):
```asm
IRP form,<fact_1[,fact_2,...]> … ENDM    ;; перебираем значения, которые по очереди будут подставляться вместо формального имени (которое мы должны указать первым операндом)
                                         ;; и это формальное имя можно использовать в теле цикла 
                                         ;; кол-во итераций цикла = кол-во параметров в угловых скобках
```
- Подстановка символов строки на место формального параметра: `IRPC` или `FORC` (в разных версиях masm'а):
```asm
IRPC form,fact … ENDM                    ;; поочерёдно перебираем все символы (элементы) строки fact
```
- Цикл с условием: `WHILE`
```asm
WHILE cond … ENDM                        ;; условие cond должно возвращать значение типа bool
                                         ;; пока cond истинно, выполняется подстановка собственного содержимого в текст программы
```



## Директивы условного ассемблирования.
Похожи на условные операторы из языков высокого уровня.<br>
Директивы:
- `IF`:
```asm
IF c1
...
ELSEIF c2                                ;; может отсутствовать, как и в условных операторах языков высокого уровня
...
ELSE                                     ;; может отсутствовать, как и в условных операторах языков высокого уровня
...
ENDIF
```
- `IFB <par>` - истинно, если параметр не определён
- `IFNB <par>` - истинно, если параметр определён
- `IFIDN <s1>,<s2>` (IF IDeNtical) - истинно, если строки совпадают
- `IFDIF <s1>,<s2>` - истинно, если строки разные
- `IFDEF/IFNDEF <name>` - истинно, если имя объявлено/не объявлен



## Директивы управления листингом.
В результате выполнения макросов получается в итоговый текст программы на ассемблере подставятся текстовые строки. Для отладки макросов (если они нетривиальные) целесообразно иметь возможность получить итоговый текст программы после выполнения всех макроподстановок, чтобы проверить корректность работы макроса. Для такой проверки существует специальный файл - файл листинга. Сформировать его можно с помощью компилятора (например, masm'а), вызвав его со специальными параметрами и указав имя листинга. Если в программе не используются макросы, то, разумеется, листинг будет мало отличаться (по большей части только форматированием) от исходного текста программы.
- **Листинг** - файл, формируемый компилятором и содержащий текст ассемблерной программы, список определённых меток, перекрёстных ссылок и сегментов.
Директивы управления листингом позволяют указывать заголовок/подзаголовок каждой страницы листинга и задавать её параметры (сколько в ней будет строк, какая у них будет ширина и т.д.).<br>
Директивы masm'а:
- `TITLE`, `SUBTTL` - заголовок, подзаголовок на каждой странице
- `PAGE` - высота, ширина
- `NAME` - имя программы
- `.LALL` - включение полных макрорасширений, кроме ;;
- `.XALL` - по умолчанию (почти полный листинг, опускается лишь небольшая часть данных)
- `.SALL` - не выводить тексты макрорасширений
- `.NOLIST` - прекратить вывод листинга



## Комментарии.
Многострочные комментарии в макросах:
```asm
comment @
... многострочный текст ...
@
```



## Виды трансляторов ассемблера.
- **MASM**
- **TASM**
- **NASM**
- **FASM**
- **YASM**
- **as**
- ...



## AT&T-синтаксис.
Синтаксис стандартного ассемблера для **UNIX** - **as**<br>
Основные отличия от **Intel-синтаксиса**:
1. Имена регистров предваряются префиксом `%`.
2. Обратный порядок операндов: вначале источник, затем приёмник.
3. Размер операнда задается суффиксом, замыкающим инструкцию.
4. Числовые константы записываются в Си-соглашении.
5. Для получения смещения метки используется префикс `$`.



## Создание оконных приложений на ассемблере под x86.
#### **Системный вызов** — обращение прикладной программы к ядру операционной системы для выполнения какой-либо операции.
Для реализации оконных приложений необходима линковка с соответствующими библиотеками и использование как их функций, так и системных вызовов.



## Дизассемблирование. Реверс-инжиниринг.
#### **Дизассемблер** - транслятор, преобразующий машинный код, объектный файл или библиотечные модули в текст программы на языке ассемблера.
#### **Дизассемблирование** - процесс получения текста программы на ассемблере из программы в машинных кодах.
#### **Реверс-инжиниринг** (обратная разработка) — исследование готовой программы с целью понять принцип работы, поиска недокументированных возможностей или внесения изменений.



